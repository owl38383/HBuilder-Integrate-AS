<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>雨淋阀</title>
		<style>
			body {
                width: 100%;
				height: 500px;
				overflow: hidden;
				margin: 0;
			}

			.threeView {
				position: relative;
			}

			canvas {
				/* canvas穿透，解决window被遮挡问题 */
				/*pointer-events: none;*/
                /*position: fixed;*/
			}
		</style>

		<!-- <script src="https://gitee.com/dcloud/uni-app/raw/dev/dist/uni.webview.1.5.4.js"></script> -->
		<script src="https://js.cdn.aliyun.dcloud.net.cn/dev/uni-app/uni.webview.1.5.2.js"></script>
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./examples/jsm/",
					"three/files/": "./files/"
				}
			}
		</script>
	</head>
	<body>
		<div id="threeView" class="threeView"></div>

		<script type="module">
			import * as THREE from 'three';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			// import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			// import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
			import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
			import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
			import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
			import { OutlinePass } from "three/addons/postprocessing/OutlinePass.js";
			import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
			// import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js'
			// import { FXAAShader } from "three/addons/shaders/FXAAShader.js"
			import { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShader.js';

			let scene, camera, renderer, controls, pointLight, ambientLight, raycaster, mouse, allObjects = [], selectedObjects = [];
			let onDownPosition, onUpPosition;
			var deviceArray = [];

			function initThree() {
				// 如果返回的不是未定义，说明threejs成功引入
				// console.log('打印场景API', THREE.Scene);
				/* 创建场景对象Scene */
				scene = new THREE.Scene();
				// scene.background = new THREE.Color(0x071a1e);
				// 坐标轴辅助
				// let helper = new THREE.AxesHelper(100, 100);
        // scene.add(helper);
				/*
				    相机设置
				 */
				var width = window.innerWidth; // 窗口宽度
				var height = window.innerHeight; // 高度
				var k = width / height; // 窗口宽高比
				var s = 1000; // 三维场景显示范围控制系数，系数越大，显示的范围越大
				// 创建相机对象（正射投影）
				camera = new THREE.PerspectiveCamera(75, k, 0.1, s);
				// camera.position.z = 500;
				// camera.position.set(0, 3500, 0); // 设置相机位置
				camera.lookAt(scene.position); // 设置相机的方向（指向场景对象）
				/*
				    光源设置
				 */
				// 点光源--光照强度
				// pointLight = new THREE.PointLight(0xffffff, 0.1, 0);
				// pointLight.position.set(50, 50, 50); // 点光源位置
				// pointLight.castShadow = true;
				// scene.add(pointLight); // 点光源添加到场景中
				// 环境光
				ambientLight = new THREE.AmbientLight(0x666666, 0.4);
				scene.add(ambientLight);
				// 平行光
				const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
				directionalLight.position.set(-20, 20, 20);
				directionalLight.castShadow = true;
				scene.add(directionalLight);
				// 光源辅助观察
				// const pointLightHelper = new THREE.PointLightHelper(pointLight, 10);
				// scene.add(pointLightHelper);
				// 可视化平行光
				// const dirLightHelper = new THREE.DirectionalLightHelper(directionalLight, 5,0xff0000);
				// scene.add(dirLightHelper);

				/*
				    创建渲染器对象
				 */
				renderer = new THREE.WebGLRenderer({
					antialias: true,
        	alpha: true
				});
				renderer.setPixelRatio(window.devicePixelRatio); // 设备像素比,适应不同的硬件设备屏幕
				renderer.setSize(width, height); // 设置渲染区域尺寸
				renderer.setClearColor(0xcdcdcd, 0.5); // 设置背景颜色
				renderer.outputEncoding = THREE.sRGBEncoding; //真实还原贴图材质颜色，解决加载gltf格式模型纹理贴图和原图不一样问题
				// renderer.toneMapping = THREE.ACESFilmicToneMapping; //色调映射
				// renderer.toneMappingExposure = -0.3; //色调映射的曝光级别。默认是1
				// renderer.physicallyCorrectLights = true; //是否使用物理上正确的光照模式。 默认是false
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.VSMShadowMap;
				const element = document.getElementById('threeView')
				element.appendChild(renderer.domElement); // body元素中插入canvas对象
				renderer.compile(scene, camera); // 使用相机编译场景中的所有材质。这对于在首次渲染之前预编译着色器很有用。
				// console.log("element", element);

				controls = new OrbitControls(camera, renderer.domElement);
                // controls.listenToKeyEvents(window);
				// controls.addEventListener('change', (e)=>{
    //                 console.log("controlschange", e);
    //             })
				controls.update();
				controls.enablePan = false;
				controls.enableDamping = true;

				// model
				const onProgress = function(xhr) {
					if (xhr.lengthComputable) {
						const percentComplete = xhr.loaded / xhr.total * 100;
						console.log(Math.round(percentComplete) + '% loaded');
					}
				};

				new MTLLoader()
					// .setPath('static/three/files/')
					.load('./files/yulin_model.mtl', (materials) => {
						materials.side = THREE.DoubleSide; //双面纹理
						materials.preload();
						new OBJLoader()
							.setMaterials(materials)
							// .setPath('static/three/files/')
							.load('./files/yulin_model.obj', (object) => {
								// object.position.y = - 95;
								// object.position.z = -295;
								object.scale.x = 0.12
								object.scale.y = 0.12
								object.scale.z = 0.12
								// object.castShadow = true;
								object.traverse((child) => {
									// console.log( "child", child );
									if (child.isMesh) {
										child.castShadow = true;
										allObjects.push(child);
										// 加上下面的配置，会导致颜色失真
										// child.material.emissive = child.material.color
										// child.material.emissiveMap = child.material.map
									}
								});
								uni.postMessage({
									data: {
										action: 2,
										message: '模型加载成功'
									}
								});
								// console.log("object", object);
								scene.add(object);
								camera.position.z = 20;
							}, onProgress, (error) => {
								console.error("OBJLoader", error);
							});
					}, undefined, (error) => {
						console.error("MTLLoader", error);
					});

				// new OBJLoader()
				// 	// .setPath('static/three/files/')
				// 	.load('./yulin_model.obj', (object)=> {
				// 		// object.position.y = - 95;
				// 		// object.position.z = -295;
				// 		object.scale.x = 0.1
				// 		object.scale.y = 0.1
				// 		object.scale.z = 0.1
				// 		// object.scale.set(1, 1, 1)
				// 		// object.castShadow = true;
				// 		object.traverse( ( child )=> {
				// 			// console.log( "child", child );
				// 			if (child.isMesh) {
				// 				child.castShadow = true;
				// 				// child.material.emissive = child.material.color
				// 				// child.material.emissiveMap = child.material.map
				// 			}
				// 		});
				// 		console.log( "object", object );
				// 		scene.add(object);
				// 		camera.position.z = 20;

				// 		// this.render();
				// 		// console.log("uni2",uni)
				// 		// uni.hideLoading();
				// 	}, onProgress, ( error )=> {
				// 		console.error( "OBJLoader", error );
				// 	});

				// 加载一个glb模型
				// new GLTFLoader()
				// 	// .setPath('three/files/')
				// 	.load('./yulin_model.glb', (gltf) => {
				// 		console.log( "gltf", gltf.scene );
				// 		// gltf.scene.scale.set(1, 1, 1)
				// 		// 查看gltf所有颜色贴图的.encoding值
				// 		gltf.scene.traverse((child) => {
				// 				// console.log( "child.isMesh", child.isMesh );
				// 		    if (child.isMesh) {
				// 						child.material.emissive = child.material.color;
				// 						child.material.emissiveIntensity = 1;
				// 						child.material.emissiveMap = child.material.map;
				// 						child.material.transparent = true;
				// 						child.isLineSegments = true;
				// 						child.material.wireframe = false;
				// 						// child.material.alphaTest = 0.2
				// 		    }
				// 		});
				// 		scene.add(gltf.scene);
				// 		camera.position.z = 200;
				// 		// gltf.animations; // Array<THREE.AnimationClip>
				// 		// gltf.scene; // THREE.Group
				// 		// gltf.scenes; // Array<THREE.Group>
				// 		// gltf.cameras; // Array<THREE.Camera>
				// 		// gltf.asset; // Object
				// 	}, onProgress, ( error ) => {
				// 		console.error( "GLTFLoader", error );
				// 	});

				// 添加一个绿色的立方体
				// const geometry = new THREE.BoxGeometry( 1, 1, 1 );
				// const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
				// cube = new THREE.Mesh( geometry, material );
				// scene.add( cube );
				// camera.position.z = 5;
				
				//创建普通模型对象
				// var geometry = new THREE.Geometry(); //声明一个几何体对象Geometry
				// //绘制圆形,参数：0, 0圆弧坐标原点x，y 100：圆弧半径 0, 2 * Math.PI：圆弧起始角度；
				// // var arc = new THREE.ArcCurve(0, 0, 5, 0, 2 * Math.PI);
				// // 参数1和2表示椭圆中心坐标  参数3和4表示x和y方向半径
				// var arc = new THREE.EllipseCurve(0, 0, 5, 10);
				// //getPoints是基类Curve的方法，返回一个vector2对象作为元素组成的数组
				// var points = arc.getPoints(50);//分段数50，返回51个顶点
				// // setFromPoints方法从points中提取数据改变几何体的顶点属性vertices
				// geometry.setFromPoints(points);
				// //材质对象
				// var material = new THREE.LineBasicMaterial({
				// 		color: 0x000000
				// });
				// //线条模型对象
				// var line = new THREE.Line(geometry, material);
				// scene.add(line); //线条对象添加到场景中
				
				// 参数：radius 半径，segments 分段
				// const geometry = new THREE.CircleGeometry( 0.5, 32 );
				// const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
				// const circle = new THREE.Mesh( geometry, material );
				// circle.position.set(1,1.5,5);
				// scene.add( circle );

				let pointList = [
					{
						id: 1,
						name: '1',
						status: 0,
						x: 2.4163194503500383,
						y: 2.0357967022634185,
						z: 4.552500057220459,
					},{
						id: 2,
						name: '2',
						status: 0,
						x: 7.584593102698935,
						y: 2.573750812627567,
						z: 1.5075000286102316,
					},{
						id: 3,
						name: '3',
						status: 0,
						x: 3.4607341450254663,
						y: 3.318192956360706,
						z: 0.2999999999999979,
					},{
						id: 4,
						name: '4',
						status: 0,
						x: 4.70860557535482,
						y: 1.7238838537775163,
						z: 4.2675001144409155,
					},{
						id: 5,
						name: '5',
						status: 0,
						x: 3.354204878116333,
						y: 0.0831834661967306,
						z: 0.2999999999999979,
					},{
						id: 6,
						name: '6',
						status: 0,
						x: 5.461013877630719,
						y: 3.8321167042192266,
						z: 0.06709319367903817,
					},{
						id: 7,
						name: '7',
						status: 1,
						x: -3.2722185272486506,
						y: 3.63587643594833,
						z: 0.5596005817295591,
					},{
						id: 8,
						name: '8',
						status: 0,
						x: -5.006698399304761,
						y: 0.24749071298085887,
						z: 0.4800000071525552,
					},{
						id: 9,
						name: '9',
						status: 1,
						x: 0.39916581428206765,
						y: 7.142230979907203,
						z: 3.926154628662597,
					},{
						id: 10,
						name: '10',
						status: 0,
						x: 0.6163713338723411,
						y: -5.455768265466475,
						z: 3.812441851882358,
					},{
						id: 11,
						name: '11',
						status: 0,
						x: -5.5233426437682045,
						y: 3.6277376074106797,
						z: 0.28577623404166985,
					},{
						id: 12,
						name: '12',
						status: 1,
						x: -3.2977499773090626,
						y: 2.9926394999453567,
						z: 2.5800001144409177,
					},{
						id: 13,
						name: '13',
						status: 0,
						x: -5.168383690109487,
						y: 0.8376406644358916,
						z: 4.177500057220459,
					}
				]
				// pointList.forEach(item=>{
				// 	addTag(item)
				// })

				// 获取鼠标坐标点击事件
                raycaster = new THREE.Raycaster(); //光线投射，用于确定鼠标点击位置
                // mouse = new THREE.Vector2(); //创建二维平面
								// 存储 鼠标按下时的二维空间点
								onDownPosition = new THREE.Vector2();
								// 存储 鼠标松开时的二维空间点
								onUpPosition = new THREE.Vector2();
				window.addEventListener("pointerdown", onPointerdown, false); // 页面绑定鼠标点击事件
                window.addEventListener('pointerup', onPointerup, false);
                // window.addEventListener('touchstart', onDocumentTouchStart, false);
                // document.addEventListener('touchend', onDocumentTouchEnd, false);
                // window.addEventListener('keydown', onKeydown);
				// console.log("scene", scene);

				render();
			}
			
			function onPointerdown(event) {
				onDownPosition.x = event.clientX;
				onDownPosition.y = event.clientY;
			}
			
			function onPointerup(event) {
				onUpPosition.x = event.clientX;
				onUpPosition.y = event.clientY;
				
				// 如果鼠标按键按下和松开的时候是在同一个点同一个位置，则取消 transformControl 变换器正在变换的模型的变化状态，然后触发点击事件
				if (onDownPosition.distanceTo(onUpPosition) === 0) {
					// transformControl.detach();
					modelclick(event)
				}
			}

			function addTag(point) {
				let statusColor = 0x1992F8
				let statusIcon = "./files/icon_status_normal.png"
				if (point.enum_device_status.status_category != "normal") {
					statusIcon = "./files/icon_status_abnormal.png"
					statusColor = 0xff710d
				}
				// 利用纹理加载器，加载一个图片，用来做标点的样式
				const map = new THREE.TextureLoader().load( statusIcon );
				//利用这个图片创建一个精灵图材质（无论在哪个视角看，精灵图材质的模型都是面向我们的），sizeAttenuation属性是让模型不随视图内容的缩小放大而缩小放大
				//depthTest是让这个模型被其它模型遮挡仍然能被看见（默认被遮住时不能透过模型被看见），opacity设置透明度（为什么要弄两个材质？为了让标点被遮住时有被遮住的效果）
				const material = new THREE.SpriteMaterial( { map: map, sizeAttenuation: false } );
				const material2 = new THREE.SpriteMaterial( { map: map, sizeAttenuation: false, depthTest: true, opacity: 0.2 } );
				let sprite1 = new THREE.Sprite( material );
				let sprite2 = new THREE.Sprite( material2 );
				// 设置精灵图模型的尺寸缩放
				sprite1.scale.set(0.06, 0.06, 0.06);
				// 设置精灵图模型初始位置
				sprite1.position.set(point.x, point.y, point.z);
				sprite1.add(sprite2)
				sprite1.isMarker = true;
				sprite1.userData = point;
				scene.add(sprite1);
				deviceArray.push(sprite1);

				// 参数：radius 半径，segments 分段
				// const geometry = new THREE.CircleGeometry( 0.5, 32 );
				// const material = new THREE.MeshBasicMaterial( { color: statusColor } );
				// const circle = new THREE.Mesh( geometry, material );
				// circle.device_id = point.id;
				// circle.device_name = point.name;
				// circle.device_status = point.status;
				// circle.device_info = point;
				// circle.position.set(point.x,point.y,point.z);
				// scene.add( circle );
			}

			function modelclick(event) {
				// console.log("modelclick", event);
				//将html坐标系转化为webgl坐标系，并确定鼠标点击位置
				// mouse.x = event.clientX / window.innerWidth * 2 - 1;
				// mouse.y = -(event.clientY / window.innerHeight * 2) + 1;
				let mouse = onTransitionMouseXYZ(event, renderer.domElement);
				//以camera为z坐标，确定所点击物体的3D空间位置
				raycaster.setFromCamera(mouse, camera);
				//确定所点击位置上的物体数量
				// console.log("scene", scene);
				var intersects = raycaster.intersectObjects(allObjects);
				// console.log("intersects", intersects);
				//选中后进行的操作
				if(intersects.length>0 && intersects[0].object.name != "Main_valve"){
					// console.log("intersects-distance", intersects[0].distance);
					// console.log("intersects-point", intersects[0].point);
					// addTag(intersects[0].point);
					// alert("距离："+intersects[0].distance);
					console.log("object", intersects[0].object);

					selectedObjects = [];
					selectedObjects.push(intersects[0].object);
					// console.log(selectedObjects)
					//调用高亮显示模型（呼吸灯）的方法给点击的格子添加点击后的样式
					outlineObj(selectedObjects);
					//拿到格子的position坐标
					// let intersectsItem = intersects[0].object;
					// positionObj = intersectsItem.geometry.boundingSphere.center;
					// console.log(positionObj)

					uni.postMessage({
						data: {
							action: 3,
							message: '点击事件',
							data: intersects[0].object.name
						}
					});
				}
				// for(let i=0;i<scene.children.length>0;i++) {
				// 	let item = scene.children[i];
				// 	if (item.type == "Group") {
				// 		var intersects = raycaster.intersectObjects(item.children);
				// 		console.log("intersects", intersects);
				// 		//选中后进行的操作
				// 		if(intersects.length>0){
				// 			console.log("intersects-distance", intersects[0].distance);
				// 			console.log("intersects-point", intersects[0].point);
				// 			// addTag(intersects[0].point);
				// 			alert("距离："+intersects[0].distance);
				// 		}
				// 		break;
				// 	}
				// }
			}
			
			// 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
			function onTransitionMouseXYZ( event, domElement ) {
			  let mouse = new THREE.Vector2();
				//通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1
				// mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				// mouse.y = -(event.clientY / (window.innerHeight - 50)) * 2 + 1;
				
			  let domElementLeft = domElement.getBoundingClientRect().left
			  let domElementTop = domElement.getBoundingClientRect().top
			  mouse.x =  ((event.clientX - domElementLeft) / domElement.clientWidth) * 2 - 1
			  mouse.y = -((event.clientY - domElementTop) / domElement.clientHeight) * 2 + 1
			  return mouse;
			}

			// 物体闪烁
			let composer = null, renderPass = null, outlinePass = null
			function outlineObj(selectedObjects) {
				// 创建一个EffectComposer（效果组合器）对象，然后在该对象上添加后期处理通道。
				composer = new EffectComposer(renderer);
				// 解决场景变暗问题
				composer.readBuffer.texture.encoding = THREE.sRGBEncoding;
				composer.writeBuffer.texture.encoding = THREE.sRGBEncoding;
				// 新建一个场景通道  为了覆盖到原理来的场景上
				renderPass = new RenderPass(scene, camera);
				composer.addPass(renderPass);
				// 物体边缘发光通道
				outlinePass = new OutlinePass(
					new THREE.Vector2(window.innerWidth, window.innerHeight),
					scene,
					camera,
					selectedObjects
				);
				outlinePass.selectedObjects = selectedObjects; // 需要高光的模型
				outlinePass.edgeStrength = 10; // 高光边缘边框的亮度
				outlinePass.edgeGlow = 1; // 光晕[0,1]  边缘微光强度
				outlinePass.usePatternTexture = false; // 是否使用父级的材质，纹理覆盖
				outlinePass.edgeThickness = 5; // 边框宽度，高光厚度
				outlinePass.downSampleRatio = 1; // 边框弯曲度
				outlinePass.pulsePeriod = 2; // 呼吸闪烁的速度，数值越大，律动越慢
				outlinePass.visibleEdgeColor.set(parseInt("0x00f6ff")); // 呼吸显示的颜色
				outlinePass.hiddenEdgeColor = new THREE.Color(0, 0, 0); // 呼吸消失的颜色
				outlinePass.clear = true;
				composer.addPass(outlinePass); // 加入高光特效

				// 解决场景变暗问题，但背景色会变暗
				// let effectFXAA = new ShaderPass(GammaCorrectionShader)
				// composer.addPass(effectFXAA)
			}

			// 模型爆炸效果
			function modelExplode(num) {
				// 模型世界中心
				var modelWorldCenter = new THREE.Vector3(0, 0, 0);//.addVectors(box.max,box.min).multiplyScalar(0.5);//模型中心坐标
				// 定义盒子
				var childBox = new THREE.Box3();
				// 遍历场景所有元素
				scene.traverse((child) => {
					// 如果元素是mesh
					if (child.isMesh) {
						childBox.setFromObject(child);
						// debugger;
						var childCenter = new THREE.Vector3().addVectors(childBox.max, childBox.min).multiplyScalar(0.1);
						if (childCenter.x) {
							child.childCenter = new THREE.Vector3().subVectors(childCenter, modelWorldCenter).normalize();
							if (child.isMesh && child.childCenter) {
								// 爆炸公式:更改mesh位置
								child.position.copy(child.childCenter).multiplyScalar(num);
							}
						}
					}
				});
			}

			// 渲染循环 或 动画循环
			function render() {
				requestAnimationFrame(render);

				// 让立方体动起来
				// cube.rotation.x += 0.01;
				// cube.rotation.y += 0.01;

				// 执行渲染操作，指定场景，相机作为参数
				renderer.render(scene, camera); //执行渲染操作
				if (composer) {
					composer.render();
				}
			}

			window.receiveData = (data)=> {
				console.log("receiveData", data);
				// alert("html接收到了数据：", data)
				// data.forEach(item=>{
				// 	addTag(item)
				// })
			}

			window.showExplode = (data)=> {
				console.log("showExplode", data);
				modelExplode(20);
				// alert("html接收到了数据：", data)
				// data.forEach(item=>{
				// 	addTag(item)
				// })
			}

			// window.onload = initThree
			// 页面加载完毕加载
			// window.addEventListener('load', () => {
			// 	console.log("load");
			//  console.log("window1", window);
			// 	initThree();
			// }, false)
			// 待触发 `UniAppJSBridgeReady` 事件后，即可调用 uni 的 API。
      document.addEventListener('UniAppJSBridgeReady', function() {
				window.onload = initThree
        uni.postMessage({
            data: {
                action: 1,
								message: '初始化成功'
            }
        });
        uni.getEnv(function(res) {
            console.log('当前环境：' + JSON.stringify(res));
        });
			})
		</script>

	</body>
</html>
